---
// Client-side component for card interactions and CardStack functionality
---

<script>
  let throttleTimeout = null;
  let activeCardStacks = new Set();
  let cardContainers = new Map();

  function handleThrottledHolo(card: HTMLElement, rotateX: number, rotateY: number) {
    if (throttleTimeout) return;
    
    throttleTimeout = setTimeout(() => {
      const hueShift = (rotateY + rotateX) * 4;
      
      if (card.classList.contains('holographic')) {
        const image = card.querySelector('.card-image') as HTMLImageElement;
        if (image) {
          requestAnimationFrame(() => {
            image.style.filter = `contrast(1.4) saturate(1.6) hue-rotate(${hueShift}deg) brightness(1.1)`;
          });
        }
      }
      
      if (card.classList.contains('foil')) {
        card.style.setProperty('--foil-hue', `${hueShift}deg`);
      }
      
      throttleTimeout = null;
    }, 55);
  }

  function handleDirectionalLight(card: HTMLElement, x: number, y: number, rect: DOMRect) {
    const cardFront = card.querySelector('.card-front') as HTMLElement;
    
    if (cardFront) {
      const lightX = (x / rect.width) * 100;
      const lightY = (y / rect.height) * 100;
      
      cardFront.style.setProperty('--light-x', `${lightX}%`);
      cardFront.style.setProperty('--light-y', `${lightY}%`);
    }
  }

  function handleCardInteraction(e: MouseEvent | TouchEvent) {
    const card = e.currentTarget as HTMLElement;
    const rect = card.getBoundingClientRect();
    
    let x: number, y: number;
    
    if (e instanceof MouseEvent) {
      x = e.clientX - rect.left;
      y = e.clientY - rect.top;
    } else {
      x = e.touches[0].clientX - rect.left;
      y = e.touches[0].clientY - rect.top;
    }
    
    const centerX = rect.width / 2;
    const centerY = rect.height / 2;
    
    const rotateX = (y - centerY) / centerY * -15;
    const rotateY = (x - centerX) / centerX * 15;
    
    card.style.transition = 'transform 0.1s ease-out';
    card.style.transform = `translateY(-30px) scale(1.15) rotateX(${rotateX}deg) rotateY(${rotateY}deg) translateZ(20px)`;
    
    handleDirectionalLight(card, x, y, rect);
    
    if (card.classList.contains('holographic') || card.classList.contains('foil')) {
      handleThrottledHolo(card, rotateX, rotateY);
    }
  }

  function handleCardReset(e: Event) {
    const card = e.currentTarget as HTMLElement;
    
    if (throttleTimeout) {
      clearTimeout(throttleTimeout);
      throttleTimeout = null;
    }
    
    card.style.transition = 'all 0.3s ease';
    card.style.transform = 'translateY(0px) scale(1)';
    
    const cardFront = card.querySelector('.card-front') as HTMLElement;
    if (cardFront) {
      cardFront.style.setProperty('--light-x', '30%');
      cardFront.style.setProperty('--light-y', '30%');
    }
    
    if (card.classList.contains('holographic')) {
      const image = card.querySelector('.card-image') as HTMLImageElement;
      if (image) {
        image.style.transition = 'filter 0.3s ease';
        requestAnimationFrame(() => {
          image.style.filter = 'contrast(1.2) saturate(1.3) hue-rotate(0deg)';
        });
      }
    }
    
    if (card.classList.contains('foil')) {
      card.style.setProperty('--foil-hue', '0deg');
    }
  }

  async function openModal(card: HTMLElement) {
    card.classList.add('flipping');
    
    // Get card data
    const cardDataStr = card.getAttribute('data-full-content');
    if (!cardDataStr) return;
    
    const cardData = JSON.parse(cardDataStr);
    const cardImage = card.querySelector('.card-image') as HTMLImageElement;
    const cardText = card.querySelector('.card-text') as HTMLElement;
    
    if (!cardImage || !cardText) return;
    
    // Create modal
    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
    `;
    
    // Start with loading content
    modal.innerHTML = `
      <div class="modal-overlay" style="
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.9);
        backdrop-filter: blur(10px);
      "></div>
      <div class="modal-content" style="
        position: absolute;
        top: 30px;
        left: 30px;
        right: 30px;
        bottom: 30px;
        background: rgba(0, 0, 0, 0.8);
        border-radius: 16px;
        overflow: hidden;
        transform: scale(0.8);
        transition: transform 0.3s ease;
      ">
        <button class="modal-close" style="
          position: absolute;
          top: 15px;
          right: 20px;
          background: rgba(0, 0, 0, 0.7);
          border: none;
          color: #fff;
          font-size: 2rem;
          cursor: pointer;
          z-index: 10;
          width: 40px;
          height: 40px;
          display: flex;
          align-items: center;
          justify-content: center;
          border-radius: 50%;
          transition: all 0.3s ease;
        ">&times;</button>
        <div class="modal-loading" style="
          display: flex;
          align-items: center;
          justify-content: center;
          height: 100%;
          color: #fff;
          font-size: 1.2rem;
        ">Loading content...</div>
      </div>
    `;
    
    document.body.appendChild(modal);
    
    setTimeout(() => {
      modal.style.opacity = '1';
      modal.style.visibility = 'visible';
      const content = modal.querySelector('.modal-content') as HTMLElement;
      if (content) {
        content.style.transform = 'scale(1)';
      }
    }, 10);
    
    // Load markdown content
    try {
      const category = card.closest('.cards-container')?.getAttribute('data-category') || 'project';
      let contentUrl = '';
      
      if (category === 'github') {
        // For GitHub, show repository info
        contentUrl = '';
      } else {
        // For other categories, load markdown content
        const slug = cardData.slug || cardData.title?.toLowerCase().replace(/\s+/g, '-');
        contentUrl = `http://localhost:4000/api/content/${category}/${slug}`;
      }
      
      if (contentUrl) {
        const response = await fetch(contentUrl);
        const contentData = await response.json();
        
        // Update modal with actual content
        const modalContent = modal.querySelector('.modal-content') as HTMLElement;
        modalContent.innerHTML = `
          <button class="modal-close" style="
            position: absolute;
            top: 15px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            border: none;
            color: #fff;
            font-size: 2rem;
            cursor: pointer;
            z-index: 10;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.3s ease;
          ">&times;</button>
          <div class="modal-body" style="
            padding: 60px 30px 30px 30px;
            height: 100%;
            overflow-y: auto;
            color: #fff;
            line-height: 1.6;
          ">
            <h1 style="color: #ffd700; margin-bottom: 20px;">${cardData.title || cardData.name}</h1>
            <div class="markdown-content">${contentData.content || contentData.html || 'No content available'}</div>
          </div>
        `;
      } else {
        // Show basic card info for GitHub
        const modalContent = modal.querySelector('.modal-content') as HTMLElement;
        modalContent.innerHTML = `
          <button class="modal-close" style="
            position: absolute;
            top: 15px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            border: none;
            color: #fff;
            font-size: 2rem;
            cursor: pointer;
            z-index: 10;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.3s ease;
          ">&times;</button>
          <div class="modal-body" style="
            padding: 60px 30px 30px 30px;
            height: 100%;
            overflow-y: auto;
            color: #fff;
            line-height: 1.6;
          ">
            <h1 style="color: #ffd700; margin-bottom: 20px;">${cardData.name || cardData.title}</h1>
            <p style="font-size: 1.1rem; margin-bottom: 20px;">${cardData.description || 'No description available'}</p>
            ${cardData.html_url ? `<a href="${cardData.html_url}" target="_blank" style="color: #ffd700; text-decoration: none;">View on GitHub â†’</a>` : ''}
          </div>
        `;
      }
    } catch (error) {
      console.error('Failed to load content:', error);
      // Show error message
      const modalContent = modal.querySelector('.modal-content') as HTMLElement;
      modalContent.innerHTML = `
        <button class="modal-close" style="
          position: absolute;
          top: 15px;
          right: 20px;
          background: rgba(0, 0, 0, 0.7);
          border: none;
          color: #fff;
          font-size: 2rem;
          cursor: pointer;
          z-index: 10;
          width: 40px;
          height: 40px;
          display: flex;
          align-items: center;
          justify-content: center;
          border-radius: 50%;
          transition: all 0.3s ease;
        ">&times;</button>
        <div class="modal-body" style="
          padding: 60px 30px 30px 30px;
          height: 100%;
          overflow-y: auto;
          color: #fff;
          line-height: 1.6;
        ">
          <h1 style="color: #ffd700; margin-bottom: 20px;">${cardData.title || cardData.name}</h1>
          <p>Failed to load content. Please try again later.</p>
        </div>
      `;
    }
    
    // Set up modal close handlers
    setTimeout(() => {
      const closeModal = () => {
        modal.style.opacity = '0';
        modal.style.visibility = 'hidden';
        const content = modal.querySelector('.modal-content') as HTMLElement;
        if (content) {
          content.style.transform = 'scale(0.8)';
        }
        
        setTimeout(() => {
          if (modal.parentNode) {
            document.body.removeChild(modal);
          }
          card.classList.remove('flipping');
          
          card.style.transition = 'all 0.3s ease';
          card.style.transform = 'translateY(0px) scale(1)';
          
          const cardFront = card.querySelector('.card-front') as HTMLElement;
          if (cardFront) {
            cardFront.style.setProperty('--light-x', '30%');
            cardFront.style.setProperty('--light-y', '30%');
          }
          
          if (card.classList.contains('holographic')) {
            const image = card.querySelector('.card-image') as HTMLImageElement;
            if (image) {
              image.style.transition = 'filter 0.3s ease';
              requestAnimationFrame(() => {
                image.style.filter = 'contrast(1.2) saturate(1.3) hue-rotate(0deg)';
              });
            }
          }
          
          if (card.classList.contains('foil')) {
            card.style.setProperty('--foil-hue', '0deg');
          }
        }, 300);
      };
      
      const closeButton = modal.querySelector('.modal-close') as HTMLElement;
      const overlay = modal.querySelector('.modal-overlay') as HTMLElement;
      
      if (closeButton) closeButton.addEventListener('click', closeModal);
      if (overlay) overlay.addEventListener('click', closeModal);
      
      const handleEscape = (e: KeyboardEvent) => {
        if (e.key === 'Escape') {
          closeModal();
          document.removeEventListener('keydown', handleEscape);
        }
      };
      document.addEventListener('keydown', handleEscape);
    }, 100);
  }

  function initializeCards() {
    const cards = document.querySelectorAll('.card:not([data-initialized])');
    
    cards.forEach(card => {
      const cardEl = card as HTMLElement;
      
      // Mark as initialized to prevent duplicate listeners
      cardEl.setAttribute('data-initialized', 'true');
      
      cardEl.addEventListener('mousemove', handleCardInteraction);
      cardEl.addEventListener('mouseleave', handleCardReset);
      cardEl.addEventListener('touchmove', (e) => {
        e.preventDefault();
        handleCardInteraction(e);
      });
      cardEl.addEventListener('touchend', handleCardReset);
      
      cardEl.addEventListener('click', () => {
        openModal(cardEl);
      });
    });
  }

  // CardStack functionality
  function handleCardStackClick(stackElement: HTMLElement) {
    const category = stackElement.getAttribute('data-category');
    console.log('handleCardStackClick called with category:', category);
    
    if (!category) {
      console.error('No category found on stack element');
      return;
    }
    
    const isActive = activeCardStacks.has(category);
    console.log('Stack is active:', isActive);
    
    if (isActive) {
      console.log('Returning cards to stack');
      returnCardsToStack(category, stackElement);
    } else {
      console.log('Dealing cards from stack');
      dealCardsFromStack(category, stackElement);
    }
  }
  
  async function dealCardsFromStack(category: string, stackElement: HTMLElement) {
    console.log('2. dealCardsFromStack - DOM ready:', document.readyState);
    console.log('3. Grid element found:', !!document.getElementById('grid'));
    console.log('3. Stack element:', stackElement);
    
    activeCardStacks.add(category);
    stackElement.classList.add('active');
    
    // Create cards container after the grid
    const grid = document.getElementById('grid');
    if (!grid) {
      console.error('Grid element not found!');
      return;
    }
    console.log('Grid element:', grid);
    
    let cardsContainer = cardContainers.get(category);
    if (!cardsContainer) {
      cardsContainer = document.createElement('div');
      cardsContainer.className = 'cards-container';
      cardsContainer.setAttribute('data-category', category);
      cardsContainer.style.cssText = `
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 20px;
        margin: 40px 20px;
        opacity: 0;
        transform: translateY(20px);
        transition: all 0.5s ease;
      `;
      
      // Insert after grid
      grid.parentNode?.insertBefore(cardsContainer, grid.nextSibling);
      cardContainers.set(category, cardsContainer);
    }
    
    // Clear existing cards
    cardsContainer.innerHTML = '';
    
    // Fetch content from backend API
    const apiUrl = category === 'github' ? 
      'http://localhost:4000/api/github/projects' : 
      `http://localhost:4000/api/content/${category}`;
    
    console.log('Fetching from API:', apiUrl);
    
    try {
      const response = await fetch(apiUrl);
      console.log('API response status:', response.status);
      const data = await response.json();
      console.log('API data received:', data);
      
      let cardItems = [];
      
      if (category === 'github') {
        cardItems = data.projects || [];
      } else {
        cardItems = data.data || [];  // Backend returns data.data, not data.items
      }
      
      console.log('Card items to create:', cardItems.length, cardItems);
      
      // Create and animate cards
      cardItems.forEach((cardData, index) => {
        console.log('Creating card', index, 'with data:', cardData);
        setTimeout(() => {
          const card = createCard(cardData, category, index);
          cardsContainer.appendChild(card);
          
          // Animate card from stack position
          const stackRect = stackElement.getBoundingClientRect();
          const containerRect = cardsContainer.getBoundingClientRect();
          
          // Calculate initial position relative to stack
          const initialX = stackRect.left - containerRect.left;
          const initialY = stackRect.top - containerRect.top;
          
          card.style.transform = `translate(${initialX}px, ${initialY}px) scale(0.5) rotateY(180deg)`;
          card.style.opacity = '0';
          
          requestAnimationFrame(() => {
            card.style.transition = 'all 0.8s cubic-bezier(0.23, 1, 0.32, 1)';
            card.style.transform = 'translate(0, 0) scale(1) rotateY(0deg)';
            card.style.opacity = '1';
          });
        }, index * 150);
      });
      
      // Show container after cards are created
      setTimeout(() => {
        cardsContainer.style.opacity = '1';
        cardsContainer.style.transform = 'translateY(0)';
      }, 100);
      
    } catch (error) {
      console.error('Failed to fetch content:', error);
      // Fallback to mock data on error
      const mockCards = [
        { title: `${category} Item 1`, image: '/placeholder.jpg', description: 'Sample description' },
        { title: `${category} Item 2`, image: '/placeholder.jpg', description: 'Sample description' }
      ];
      
      mockCards.forEach((cardData, index) => {
        setTimeout(() => {
          const card = createCard(cardData, category, index);
          cardsContainer.appendChild(card);
          
          const stackRect = stackElement.getBoundingClientRect();
          const containerRect = cardsContainer.getBoundingClientRect();
          
          const initialX = stackRect.left - containerRect.left;
          const initialY = stackRect.top - containerRect.top;
          
          card.style.transform = `translate(${initialX}px, ${initialY}px) scale(0.5) rotateY(180deg)`;
          card.style.opacity = '0';
          
          requestAnimationFrame(() => {
            card.style.transition = 'all 0.8s cubic-bezier(0.23, 1, 0.32, 1)';
            card.style.transform = 'translate(0, 0) scale(1) rotateY(0deg)';
            card.style.opacity = '1';
          });
        }, index * 150);
      });
    }
    
    // Show container
    setTimeout(() => {
      cardsContainer.style.opacity = '1';
      cardsContainer.style.transform = 'translateY(0)';
    }, 100);
  }
  
  function returnCardsToStack(category: string, stackElement: HTMLElement) {
    activeCardStacks.delete(category);
    stackElement.classList.remove('active');
    
    const cardsContainer = cardContainers.get(category);
    if (!cardsContainer) return;
    
    const cards = cardsContainer.querySelectorAll('.card');
    const stackRect = stackElement.getBoundingClientRect();
    const containerRect = cardsContainer.getBoundingClientRect();
    
    cards.forEach((card, index) => {
      const cardElement = card as HTMLElement;
      
      setTimeout(() => {
        const initialX = stackRect.left - containerRect.left;
        const initialY = stackRect.top - containerRect.top;
        
        cardElement.style.transition = 'all 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55)';
        cardElement.style.transform = `translate(${initialX}px, ${initialY}px) scale(0.3) rotateY(180deg)`;
        cardElement.style.opacity = '0';
      }, index * 100);
    });
    
    // Hide container and remove cards
    setTimeout(() => {
      cardsContainer.style.opacity = '0';
      cardsContainer.style.transform = 'translateY(20px)';
      
      setTimeout(() => {
        cardsContainer.innerHTML = '';
      }, 500);
    }, cards.length * 100 + 200);
  }
  
  function createCard(cardData: any, category: string, index: number) {
    const card = document.createElement('div');
    const isHolo = category === 'project' || category === 'github';
    
    // Extract data based on category
    let title: string, image: string, description: string;
    
    if (category === 'github') {
      title = cardData.name || cardData.title || 'GitHub Project';
      image = cardData.owner?.avatar_url || '/placeholder.jpg';
      description = cardData.description || 'GitHub repository';
    } else {
      title = cardData.title || cardData.name || 'Content Item';
      image = cardData.image || '/placeholder.jpg';
      description = cardData.description || 'Content description';
    }
    
    card.className = `card ${isHolo ? 'holographic' : 'normal'}`;
    card.style.cssText = `
      aspect-ratio: 3/4;
      position: relative;
      border-radius: 8px;
      overflow: hidden;
      cursor: pointer;
      transform-style: preserve-3d;
      transition: all 0.3s ease;
      background: linear-gradient(135deg, #ffd700, #b8860b);
      border: 1px solid rgba(218, 165, 32, 0.3);
      backdrop-filter: blur(5px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    `;
    
    card.innerHTML = `
      <div class="card-front" style="
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 20px;
        box-sizing: border-box;
        --light-x: 30%;
        --light-y: 30%;
      ">
        <div class="card-image" style="
          width: 80%;
          height: 60%;
          background: url('${image}') center/cover;
          border-radius: 4px;
          margin-bottom: 10px;
          ${isHolo ? 'filter: contrast(1.2) saturate(1.3);' : ''}
        "></div>
        <div class="card-text" style="
          font-size: 1rem;
          font-weight: bold;
          color: #000;
          text-align: center;
          text-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
        ">${title}</div>
      </div>
    `;
    
    // Store full data for modal
    card.setAttribute('data-full-content', JSON.stringify(cardData));
    
    if (isHolo) {
      card.style.background = 'linear-gradient(135deg, #ffd700, #b8860b, #ffa500, #ffb347)';
      card.style.backgroundSize = '400% 400%';
      card.style.animation = 'holographicShimmer 3s ease-in-out infinite';
    }
    
    // Add event listeners to the dynamically created card
    card.addEventListener('mousemove', handleCardInteraction);
    card.addEventListener('mouseleave', handleCardReset);
    card.addEventListener('touchmove', (e) => {
      e.preventDefault();
      handleCardInteraction(e);
    });
    card.addEventListener('touchend', handleCardReset);
    card.addEventListener('click', () => {
      openModal(card);
    });
    
    return card;
  }
  
  function initializeCardStacks() {
    const cardStacks = document.querySelectorAll('.card-stack:not([data-initialized])');
    console.log('Found', cardStacks.length, 'card stacks to initialize');
    
    cardStacks.forEach(stack => {
      const stackEl = stack as HTMLElement;
      const category = stackEl.getAttribute('data-category');
      console.log('Initializing stack with category:', category);
      
      stackEl.setAttribute('data-initialized', 'true');
      
      stackEl.addEventListener('click', (e) => {
        console.log('CardStack clicked:', category);
        e.preventDefault();
        e.stopPropagation();
        handleCardStackClick(stackEl);
      });
    });
  }

  // Run immediately and also on DOM ready
  function init() {
    initializeCards();
    initializeCardStacks();
    console.log('CardInteractions initialized');
  }
  
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
  
  // Also run on window load as backup
  window.addEventListener('load', init);
</script>

<style>
  @keyframes holographicShimmer {
    0% {
      background-position: 0% 50%;
    }
    50% {
      background-position: 100% 50%;
    }
    100% {
      background-position: 0% 50%;
    }
  }
  
  .cards-container {
    animation: slideIn 0.5s ease-out;
  }
  
  @keyframes slideIn {
    from {
      opacity: 0;
      transform: translateY(30px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }
</style>