---
// Client-side component for card interactions and modal functionality
---

<script>
  let throttleTimeout = null;
  let activeCategories = new Set();
  let cardContainers = new Map();
  let initialized = false;

  function handleThrottledHolo(card: HTMLElement, rotateX: number, rotateY: number) {
    if (throttleTimeout) return;
    
    throttleTimeout = setTimeout(() => {
      const hueShift = (rotateY + rotateX) * 4;
      
      if (card.classList.contains('holographic')) {
        const image = card.querySelector('.card-image') as HTMLImageElement;
        if (image) {
          requestAnimationFrame(() => {
            image.style.filter = `contrast(1.4) saturate(1.6) hue-rotate(${hueShift}deg) brightness(1.1)`;
          });
        }
      }
      
      if (card.classList.contains('foil')) {
        card.style.setProperty('--foil-hue', `${hueShift}deg`);
      }
      
      throttleTimeout = null;
    }, 55);
  }

  function handleDirectionalLight(card: HTMLElement, x: number, y: number, rect: DOMRect) {
    const cardFront = card.querySelector('.card-front') as HTMLElement;
    
    if (cardFront) {
      const lightX = (x / rect.width) * 100;
      const lightY = (y / rect.height) * 100;
      
      cardFront.style.setProperty('--light-x', `${lightX}%`);
      cardFront.style.setProperty('--light-y', `${lightY}%`);
    }
  }

  function handleCardInteraction(e: MouseEvent | TouchEvent) {
    const card = e.currentTarget as HTMLElement;
    const rect = card.getBoundingClientRect();
    
    let x: number, y: number;
    
    if (e instanceof MouseEvent) {
      x = e.clientX - rect.left;
      y = e.clientY - rect.top;
    } else {
      x = e.touches[0].clientX - rect.left;
      y = e.touches[0].clientY - rect.top;
    }
    
    const centerX = rect.width / 2;
    const centerY = rect.height / 2;
    
    const rotateX = (y - centerY) / centerY * -15;
    const rotateY = (x - centerX) / centerX * 15;
    
    card.style.transition = 'transform 0.1s ease-out';
    card.style.transform = `translateY(-30px) scale(1.15) rotateX(${rotateX}deg) rotateY(${rotateY}deg) translateZ(20px)`;
    
    handleDirectionalLight(card, x, y, rect);
    
    if (card.classList.contains('holographic') || card.classList.contains('foil')) {
      handleThrottledHolo(card, rotateX, rotateY);
    }
  }

  function handleCardReset(e: Event) {
    const card = e.currentTarget as HTMLElement;
    
    if (throttleTimeout) {
      clearTimeout(throttleTimeout);
      throttleTimeout = null;
    }
    
    card.style.transition = 'all 0.3s ease';
    card.style.transform = 'translateY(0px) scale(1)';
    
    const cardFront = card.querySelector('.card-front') as HTMLElement;
    if (cardFront) {
      cardFront.style.setProperty('--light-x', '30%');
      cardFront.style.setProperty('--light-y', '30%');
    }
    
    if (card.classList.contains('holographic')) {
      const image = card.querySelector('.card-image') as HTMLImageElement;
      if (image) {
        image.style.transition = 'filter 0.3s ease';
        requestAnimationFrame(() => {
          image.style.filter = 'contrast(1.2) saturate(1.3) hue-rotate(0deg)';
        });
      }
    }
    
    if (card.classList.contains('foil')) {
      card.style.setProperty('--foil-hue', '0deg');
    }
  }

  function scaleModalImages(modal: HTMLElement) {
    const images = modal.querySelectorAll('img');
    const videos = modal.querySelectorAll('video');
    
    // Get modal width to calculate 80% threshold
    const modalContent = modal.querySelector('.modal-content') as HTMLElement;
    if (!modalContent) return;
    
    const modalWidth = modalContent.offsetWidth;
    const targetMaxWidth = Math.floor(modalWidth * 0.8);
    
    images.forEach(img => {
      // Force load the image to get its natural dimensions
      const tempImg = new Image();
      tempImg.onload = () => {
        const naturalWidth = tempImg.naturalWidth;
        
        // Apply responsive styling based on image size relative to modal
        if (naturalWidth > targetMaxWidth) {
          // Large images: scale down to 80% of modal width
          img.style.setProperty('max-width', `${targetMaxWidth}px`, 'important');
          img.style.setProperty('width', `${targetMaxWidth}px`, 'important');
          img.style.setProperty('height', 'auto', 'important');
        } else {
          // Small images: keep original size, but don't exceed 80% modal width
          img.style.setProperty('max-width', `${targetMaxWidth}px`, 'important');
          img.style.setProperty('width', 'auto', 'important');
          img.style.setProperty('height', 'auto', 'important');
        }
        
        // Handle long/tall images - max height based on viewport
        img.style.setProperty('max-height', 'calc(100vh - 200px)', 'important');
        
        // Maintain aspect ratio and prevent distortion
        img.style.setProperty('object-fit', 'contain', 'important');
        
        // Center the image with margins
        img.style.setProperty('display', 'block', 'important');
        img.style.setProperty('margin', '15px auto', 'important');
        img.style.setProperty('border-radius', '4px', 'important');
        
        // Ensure no horizontal scroll
        img.style.setProperty('box-sizing', 'border-box', 'important');
      };
      
      tempImg.src = img.src;
    });
    
    // Handle videos with same scaling logic
    videos.forEach(video => {
      const videoWidth = video.videoWidth || video.offsetWidth || video.clientWidth;
      
      if (videoWidth > targetMaxWidth) {
        // Large videos: scale down to 80% of modal width
        video.style.setProperty('max-width', `${targetMaxWidth}px`, 'important');
        video.style.setProperty('width', `${targetMaxWidth}px`, 'important');
      } else {
        // Small videos: keep original size but don't exceed threshold
        video.style.setProperty('max-width', `${targetMaxWidth}px`, 'important');
        video.style.setProperty('width', 'auto', 'important');
      }
      
      video.style.setProperty('height', 'auto', 'important');
      video.style.setProperty('max-height', 'calc(100vh - 200px)', 'important');
      video.style.setProperty('object-fit', 'contain', 'important');
      video.style.setProperty('display', 'block', 'important');
      video.style.setProperty('margin', '15px auto', 'important');
      video.style.setProperty('border-radius', '4px', 'important');
      video.style.setProperty('box-sizing', 'border-box', 'important');
    });
  }

  function applyModalScrollbarStyling(modal: HTMLElement) {
    // Create a style element for scrollbar styling
    const styleId = 'modal-scrollbar-styles';
    if (!document.getElementById(styleId)) {
      const style = document.createElement('style');
      style.id = styleId;
      style.textContent = `
        /* Modal scrollbar styling - dynamically applied */
        .modal-body::-webkit-scrollbar {
          width: 16px !important;
        }
        
        .modal-body::-webkit-scrollbar-track {
          background: #1a1a1a !important;
          border-radius: 0 !important;
        }
        
        .modal-body::-webkit-scrollbar-thumb {
          background: #ffffff !important;
          border-radius: 6px !important;
          border: 2px solid #1a1a1a !important;
        }
        
        .modal-body::-webkit-scrollbar-thumb:hover {
          background: #e0e0e0 !important;
        }
        
        .modal-body::-webkit-scrollbar-corner {
          background: #1a1a1a !important;
        }
        
        /* Firefox fallback */
        .modal-body {
          scrollbar-width: auto !important;
          scrollbar-color: #ffffff #1a1a1a !important;
        }
      `;
      document.head.appendChild(style);
    }
    
    // Also apply styles directly to the modal body element
    const modalBody = modal.querySelector('.modal-body') as HTMLElement;
    if (modalBody) {
      // Force scrollbar colors for Firefox
      modalBody.style.setProperty('scrollbar-width', 'auto', 'important');
      modalBody.style.setProperty('scrollbar-color', '#ffffff #1a1a1a', 'important');
    }
  }

  async function openModal(card: HTMLElement) {
    card.classList.add('flipping');
    
    // Get card data
    const cardDataStr = card.getAttribute('data-full-content');
    if (!cardDataStr) return;
    
    const cardData = JSON.parse(cardDataStr);
    const cardImage = card.querySelector('.card-image') as HTMLImageElement;
    const cardText = card.querySelector('.card-text') as HTMLElement;
    
    if (!cardImage || !cardText) return;
    
    // Create modal
    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
    `;
    
    // Start with loading content
    modal.innerHTML = `
      <div class="modal-overlay" style="
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.9);
        backdrop-filter: blur(10px);
      "></div>
      <div class="modal-content" style="
        position: absolute;
        top: 30px;
        left: 30px;
        right: 30px;
        bottom: 30px;
        background: rgba(0, 0, 0, 0.8);
        border-radius: 16px;
        overflow: hidden;
        transform: scale(0.8);
        transition: transform 0.3s ease;
      ">
        <button class="modal-close" style="
          position: absolute;
          top: 15px;
          right: 20px;
          background: rgba(0, 0, 0, 0.7);
          border: none;
          color: #fff;
          font-size: 2rem;
          cursor: pointer;
          z-index: 10;
          width: 40px;
          height: 40px;
          display: flex;
          align-items: center;
          justify-content: center;
          border-radius: 50%;
          transition: all 0.3s ease;
        ">&times;</button>
        <div class="modal-loading" style="
          display: flex;
          align-items: center;
          justify-content: center;
          height: 100%;
          color: #fff;
          font-size: 1.2rem;
        ">Loading content...</div>
      </div>
    `;
    
    document.body.appendChild(modal);
    
    setTimeout(() => {
      modal.style.opacity = '1';
      modal.style.visibility = 'visible';
      const content = modal.querySelector('.modal-content') as HTMLElement;
      if (content) {
        content.style.transform = 'scale(1)';
      }
    }, 10);
    
    // Load markdown content
    try {
      const category = cardData.category || 'project';
      let contentUrl = '';
      
      if (category === 'github') {
        // For GitHub, use the readme_html directly from cardData
        const modalContent = modal.querySelector('.modal-content') as HTMLElement;
        modalContent.innerHTML = `
          <button class="modal-close" style="
            position: absolute;
            top: 15px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            border: none;
            color: #fff;
            font-size: 2rem;
            cursor: pointer;
            z-index: 10;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.3s ease;
          ">&times;</button>
          <div class="modal-body" style="
            padding: 60px 20px 30px 20px;
            height: 100%;
            overflow-y: auto;
            overflow-x: hidden;
            color: #fff;
            line-height: 1.6;
            box-sizing: border-box;
          ">
            <div style="margin-bottom: 20px;">
              <h1 style="color: #ffd700; margin-bottom: 10px;">${cardData.display_name || cardData.name || cardData.title}</h1>
              <div style="display: flex; gap: 15px; margin-bottom: 15px; font-size: 0.9rem; color: #ccc;">
                <span>‚≠ê ${cardData.stars || 0} stars</span>
                <span>üç¥ ${cardData.forks || 0} forks</span>
                ${cardData.url ? `<a href="${cardData.url}" target="_blank" style="color: #ffd700; text-decoration: none;">View on GitHub ‚Üí</a>` : ''}
              </div>
            </div>
            <div class="markdown-content github-readme" style="border-top: 1px solid #333; padding-top: 20px;">${cardData.readme_html || 'README not available'}</div>
          </div>
        `;
        
        // Apply image scaling, syntax highlighting, and scrollbar styling after modal content is loaded
        setTimeout(() => {
          scaleModalImages(modal);
          applyModalScrollbarStyling(modal);
          // Apply syntax highlighting to code blocks
          if (window.Prism) {
            window.Prism.highlightAllUnder(modal);
          }
        }, 50);
      } else {
        // For other categories, load markdown content
        const slug = cardData.slug || cardData.title?.toLowerCase().replace(/\s+/g, '-');
        contentUrl = `/api/content/${category}/${slug}`;
        
        const response = await fetch(contentUrl);
        const contentData = await response.json();
        
        // Update modal with actual content
        const modalContent = modal.querySelector('.modal-content') as HTMLElement;
        modalContent.innerHTML = `
          <button class="modal-close" style="
            position: absolute;
            top: 15px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            border: none;
            color: #fff;
            font-size: 2rem;
            cursor: pointer;
            z-index: 10;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.3s ease;
          ">&times;</button>
          <div class="modal-body" style="
            padding: 60px 20px 30px 20px;
            height: 100%;
            overflow-y: auto;
            overflow-x: hidden;
            color: #fff;
            line-height: 1.6;
            box-sizing: border-box;
          ">
            <h1 style="color: #ffd700; margin-bottom: 20px;">${cardData.metadata?.title || cardData.title || cardData.name}</h1>
            <div class="markdown-content">${contentData.data?.html_content || contentData.content || contentData.html || contentData.html_content || 'No content available'}</div>
          </div>
        `;
        
        // Apply image scaling, syntax highlighting, and scrollbar styling after modal content is loaded
        setTimeout(() => {
          scaleModalImages(modal);
          applyModalScrollbarStyling(modal);
          // Apply syntax highlighting to code blocks
          if (window.Prism) {
            window.Prism.highlightAllUnder(modal);
          }
        }, 50);
      }
    } catch (error) {
      console.error('Failed to load content:', error);
      // Show error message
      const modalContent = modal.querySelector('.modal-content') as HTMLElement;
      modalContent.innerHTML = `
        <button class="modal-close" style="
          position: absolute;
          top: 15px;
          right: 20px;
          background: rgba(0, 0, 0, 0.7);
          border: none;
          color: #fff;
          font-size: 2rem;
          cursor: pointer;
          z-index: 10;
          width: 40px;
          height: 40px;
          display: flex;
          align-items: center;
          justify-content: center;
          border-radius: 50%;
          transition: all 0.3s ease;
        ">&times;</button>
        <div class="modal-body" style="
          padding: 60px 30px 30px 30px;
          height: 100%;
          overflow-y: auto;
          color: #fff;
          line-height: 1.6;
        ">
          <h1 style="color: #ffd700; margin-bottom: 20px;">${cardData.metadata?.title || cardData.title || cardData.name}</h1>
          <p>Failed to load content. Please try again later.</p>
        </div>
      `;
    }
    
    // Set up modal close handlers
    setTimeout(() => {
      const closeModal = () => {
        modal.style.opacity = '0';
        modal.style.visibility = 'hidden';
        const content = modal.querySelector('.modal-content') as HTMLElement;
        if (content) {
          content.style.transform = 'scale(0.8)';
        }
        
        setTimeout(() => {
          if (modal.parentNode) {
            document.body.removeChild(modal);
          }
          card.classList.remove('flipping');
          
          card.style.transition = 'all 0.3s ease';
          card.style.transform = 'translateY(0px) scale(1)';
          
          const cardFront = card.querySelector('.card-front') as HTMLElement;
          if (cardFront) {
            cardFront.style.setProperty('--light-x', '30%');
            cardFront.style.setProperty('--light-y', '30%');
          }
          
          if (card.classList.contains('holographic')) {
            const image = card.querySelector('.card-image') as HTMLImageElement;
            if (image) {
              image.style.transition = 'filter 0.3s ease';
              requestAnimationFrame(() => {
                image.style.filter = 'contrast(1.2) saturate(1.3) hue-rotate(0deg)';
              });
            }
          }
          
          if (card.classList.contains('foil')) {
            card.style.setProperty('--foil-hue', '0deg');
          }
        }, 300);
      };
      
      const closeButton = modal.querySelector('.modal-close') as HTMLElement;
      const overlay = modal.querySelector('.modal-overlay') as HTMLElement;
      
      if (closeButton) closeButton.addEventListener('click', closeModal);
      if (overlay) overlay.addEventListener('click', closeModal);
      
      const handleEscape = (e: KeyboardEvent) => {
        if (e.key === 'Escape') {
          closeModal();
          document.removeEventListener('keydown', handleEscape);
        }
      };
      document.addEventListener('keydown', handleEscape);
    }, 100);
  }

  function initializeCards() {
    const cards = document.querySelectorAll('.card:not([data-initialized])');
    
    cards.forEach(card => {
      const cardEl = card as HTMLElement;
      
      // Mark as initialized to prevent duplicate listeners
      cardEl.setAttribute('data-initialized', 'true');
      
      cardEl.addEventListener('mousemove', handleCardInteraction);
      cardEl.addEventListener('mouseleave', handleCardReset);
      cardEl.addEventListener('touchmove', (e) => {
        e.preventDefault();
        handleCardInteraction(e);
      });
      cardEl.addEventListener('touchend', handleCardReset);
      
      cardEl.addEventListener('click', () => {
        openModal(cardEl);
      });
    });
  }

  // Category button functionality
  function handleCategoryButtonClick(buttonElement: HTMLElement) {
    const category = buttonElement.getAttribute('data-category');
    console.log('handleCategoryButtonClick called with category:', category);
    
    if (!category) {
      console.error('No category found on button element');
      return;
    }
    
    const isActive = activeCategories.has(category);
    console.log('Category is active:', isActive);
    
    if (isActive) {
      console.log('Hiding cards for category');
      hideCardsForCategory(category, buttonElement);
    } else {
      console.log('Showing cards for category');
      dealCardsFromCategory(category, buttonElement);
    }
  }
  
  async function dealCardsFromCategory(category: string, buttonElement: HTMLElement | null) {
    console.log('2. dealCardsFromCategory - DOM ready:', document.readyState);
    console.log('3. Grid element found:', !!document.getElementById('grid'));
    console.log('3. Button element:', buttonElement);
    
    activeCategories.add(category);
    if (buttonElement) {
      buttonElement.classList.add('active');
    }
    
    // Create cards container after the grid
    const grid = document.getElementById('grid');
    if (!grid) {
      console.error('Grid element not found!');
      return;
    }
    console.log('Grid element:', grid);
    
    let cardsContainer = cardContainers.get(category);
    if (!cardsContainer) {
      cardsContainer = document.createElement('div');
      cardsContainer.className = 'cards-container';
      cardsContainer.setAttribute('data-category', category);
      cardsContainer.style.cssText = `
        display: none;
        grid-template-columns: repeat(auto-fit, 140px);
        gap: 20px;
        margin: 1px 20px;
        padding-top: 2px;
        opacity: 0;
        transform: translateY(20px);
        transition: all 0.5s ease, max-height 0.5s ease;
        justify-content: center;
        justify-items: center;
        width: calc(100% - 40px);
        overflow: visible;
      `;
      
      cardContainers.set(category, cardsContainer);
    }
    
    // Always move this container to be first after the grid (on top)
    if (cardsContainer.parentNode) {
      cardsContainer.parentNode.removeChild(cardsContainer);
    }
    grid.parentNode?.insertBefore(cardsContainer, grid.nextSibling);
    
    // Clear existing cards
    cardsContainer.innerHTML = '';
    
    // Fetch content from backend API
    const apiUrl = category === 'github' ? 
      '/api/github/projects' : 
      `/api/content/${category}`;
    
    console.log('Fetching from API:', apiUrl);
    
    try {
      const response = await fetch(apiUrl);
      console.log('API response status:', response.status);
      const data = await response.json();
      console.log('API data received:', data);
      
      let cardItems = [];
      
      if (category === 'github') {
        cardItems = data.data || [];
      } else {
        cardItems = data.data || [];  // Backend returns data.data, not data.items
      }
      
      // Sort cards to show featured items first
      cardItems = cardItems.sort((a: any, b: any) => {
        // Check feature status based on category
        let isFeatureA = false;
        let isFeatureB = false;
        
        if (category === 'github') {
          // GitHub uses feature property in config
          isFeatureA = a.feature === true;
          isFeatureB = b.feature === true;
        } else {
          // Projects and blogs use feature property in metadata
          isFeatureA = a.metadata?.feature === true;
          isFeatureB = b.metadata?.feature === true;
        }
        
        // Featured items first
        if (isFeatureA && !isFeatureB) return -1;
        if (!isFeatureA && isFeatureB) return 1;
        
        // Within same feature status, maintain original order
        return 0;
      });
      
      console.log('Card items to create (sorted):', cardItems.length, cardItems);
      
      // Create and animate cards
      cardItems.forEach((cardData, index) => {
        console.log('Creating card', index, 'with data:', cardData);
        setTimeout(() => {
          const card = createCard(cardData, category, index);
          cardsContainer.appendChild(card);
          
          // Animate card from center position
          const containerRect = cardsContainer.getBoundingClientRect();
          const gridRect = grid.getBoundingClientRect();
          
          // Calculate initial position relative to grid center
          const initialX = (gridRect.left + gridRect.width / 2) - (containerRect.left + containerRect.width / 2);
          const initialY = (gridRect.top + gridRect.height / 2) - (containerRect.top + containerRect.height / 2);
          
          card.style.transform = `translate(${initialX}px, ${initialY}px) scale(0.5) rotateY(180deg)`;
          card.style.opacity = '0';
          
          requestAnimationFrame(() => {
            card.style.transition = 'all 0.8s cubic-bezier(0.23, 1, 0.32, 1)';
            card.style.transform = 'translate(0, 0) scale(1) rotateY(0deg)';
            card.style.opacity = '1';
          });
        }, index * 150);
      });
      
      // Show container after cards are created
      setTimeout(() => {
        cardsContainer.style.opacity = '1';
        cardsContainer.style.transform = 'translateY(0)';
      }, 100);
      
    } catch (error) {
      console.error('Failed to fetch content:', error);
      // Fallback to mock data on error
      const mockCards = [
        { title: `${category} Item 1`, image: '/placeholder.jpg', description: 'Sample description' },
        { title: `${category} Item 2`, image: '/placeholder.jpg', description: 'Sample description' }
      ];
      
      mockCards.forEach((cardData, index) => {
        setTimeout(() => {
          const card = createCard(cardData, category, index);
          cardsContainer.appendChild(card);
          
          const containerRect = cardsContainer.getBoundingClientRect();
          const gridRect = grid.getBoundingClientRect();
          
          const initialX = (gridRect.left + gridRect.width / 2) - (containerRect.left + containerRect.width / 2);
          const initialY = (gridRect.top + gridRect.height / 2) - (containerRect.top + containerRect.height / 2);
          
          card.style.transform = `translate(${initialX}px, ${initialY}px) scale(0.5) rotateY(180deg)`;
          card.style.opacity = '0';
          
          requestAnimationFrame(() => {
            card.style.transition = 'all 0.8s cubic-bezier(0.23, 1, 0.32, 1)';
            card.style.transform = 'translate(0, 0) scale(1) rotateY(0deg)';
            card.style.opacity = '1';
          });
        }, index * 150);
      });
    }
    
    // Show container
    setTimeout(() => {
      cardsContainer.style.display = 'grid';
      cardsContainer.style.opacity = '1';
      cardsContainer.style.transform = 'translateY(0)';
    }, 100);
  }
  
  function hideCardsForCategory(category: string, buttonElement: HTMLElement) {
    activeCategories.delete(category);
    buttonElement.classList.remove('active');
    
    const cardsContainer = cardContainers.get(category);
    if (!cardsContainer) return;
    
    const cards = cardsContainer.querySelectorAll('.card');
    const buttonRect = buttonElement.getBoundingClientRect();
    const containerRect = cardsContainer.getBoundingClientRect();
    
    cards.forEach((card, index) => {
      const cardElement = card as HTMLElement;
      
      setTimeout(() => {
        const initialX = buttonRect.left - containerRect.left;
        const initialY = buttonRect.top - containerRect.top;
        
        cardElement.style.transition = 'all 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55)';
        cardElement.style.transform = `translate(${initialX}px, ${initialY}px) scale(0.3) rotateY(180deg)`;
        cardElement.style.opacity = '0';
      }, index * 100);
    });
    
    // Flip-disappear-reappear animation for remaining cards
    setTimeout(() => {
      // 1. Get all remaining card containers that will move
      const allContainers = Array.from(document.querySelectorAll('.cards-container'));
      const currentIndex = allContainers.indexOf(cardsContainer);
      const remainingContainers = allContainers.slice(currentIndex + 1);
      
      // 2. Start flip-out animation for remaining cards
      if (remainingContainers.length > 0) {
        remainingContainers.forEach((container, index) => {
          const cards = container.querySelectorAll('.card');
          cards.forEach((card, cardIndex) => {
            setTimeout(() => {
              card.style.transition = 'transform 0.3s ease-in, opacity 0.3s ease-in';
              card.style.transform = 'rotateY(90deg) scale(0.8)';
              card.style.opacity = '0';
            }, cardIndex * 50);
          });
        });
      }
      
      // 3. Remove current container
      cardsContainer.style.transition = 'opacity 0.3s ease-out';
      cardsContainer.style.opacity = '0';
      
      setTimeout(() => {
        if (cardsContainer.parentNode) {
          cardsContainer.parentNode.removeChild(cardsContainer);
        }
        cardContainers.delete(category);
        
        // 4. After DOM removal, flip remaining cards back in at new positions
        if (remainingContainers.length > 0) {
          setTimeout(() => {
            remainingContainers.forEach((container, index) => {
              const cards = container.querySelectorAll('.card');
              cards.forEach((card, cardIndex) => {
                setTimeout(() => {
                  card.style.transition = 'transform 0.4s ease-out, opacity 0.4s ease-out';
                  card.style.transform = 'rotateY(0deg) scale(1)';
                  card.style.opacity = '1';
                }, cardIndex * 50);
              });
            });
          }, 100);
        }
      }, 300);
    }, cards.length * 100 + 200);
  }
  
  function createCard(cardData: any, category: string, index: number) {
    const card = document.createElement('div');
    
    // Determine if card is featured (and thus holographic)
    let isFeature = false;
    if (category === 'github') {
      // GitHub uses feature property in config
      isFeature = cardData.feature === true;
    } else {
      // Projects and blogs use feature property in metadata
      isFeature = cardData.metadata?.feature === true;
    }
    
    const isHolo = isFeature;
    
    // Extract data based on category
    let title: string, image: string, description: string;
    
    if (category === 'github') {
      title = cardData.display_name || cardData.name || cardData.title || 'GitHub Project';
      image = cardData.image || '/placeholder.jpg';
      description = cardData.description || 'GitHub repository';
    } else {
      // For content items, data is in cardData.metadata
      title = cardData.metadata?.title || cardData.title || cardData.name || 'Content Item';
      image = cardData.metadata?.image || cardData.image || '/placeholder.jpg';
      description = cardData.metadata?.description || cardData.description || 'Content description';
    }
    
    card.className = `card ${isHolo ? 'holographic' : 'normal'}`;
    card.setAttribute('data-category', category);
    card.style.cssText = `
      aspect-ratio: 3/4;
      position: relative;
      border-radius: 8px;
      background: transparent;
      transition: all 0.3s ease;
      cursor: pointer;
      transform-style: preserve-3d;
      transform: translateY(0px) scale(1);
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
      width: 140px;
      height: 187px;
    `;
    
    card.innerHTML = `
      <div class="card-inner" style="
        position: relative;
        width: 100%;
        height: 100%;
        border-radius: 8px;
        transform-style: preserve-3d;
        transition: transform 0.6s;
      ">
        <div class="card-face card-front" style="
          position: absolute;
          width: 100%;
          height: 100%;
          border-radius: 8px;
          backface-visibility: hidden;
          background: rgba(0, 0, 0, 0.3);
          backdrop-filter: blur(5px);
          transform: rotateY(0deg);
          overflow: hidden;
        ">
          <img src="${image}" alt="${title}" class="card-image" style="
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: filter 0.1s ease;
            position: relative;
            ${isHolo ? 'filter: contrast(1.2) saturate(1.3) hue-rotate(0deg);' : ''}
          ">
          <div class="card-overlay" style="
            position: absolute;
            bottom: -5px;
            left: -5px;
            right: -5px;
            height: 70%;
            background: linear-gradient(
              to bottom,
              transparent 0%,
              transparent 8%,
              rgba(0, 0, 0, 0.1) 20%,
              rgba(0, 0, 0, 0.4) 50%,
              rgba(0, 0, 0, 0.8) 80%,
              rgba(0, 0, 0, 0.95) 95%,
              rgba(0, 0, 0, 1) 100%
            );
            pointer-events: none;
            z-index: 4;
            border-radius: 0 0 8px 8px;
          "></div>
          <div class="card-text" style="
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 12px;
            color: #fff;
            font-size: 12px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 5;
            line-height: 1.3;
            transition: none;
          ">${title}</div>
        </div>
        <div class="card-face card-back" style="
          position: absolute;
          width: 100%;
          height: 100%;
          border-radius: 8px;
          backface-visibility: hidden;
          background: linear-gradient(135deg, #ffd700, #b8860b);
          border: 1px solid rgba(218, 165, 32, 0.3);
          transform: rotateY(180deg);
          display: flex;
          align-items: center;
          justify-content: center;
        ">
          <div class="card-back-text" style="
            font-size: 1.5rem;
            font-weight: bold;
            color: #000;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
            letter-spacing: 2px;
            text-align: center;
            padding: 0 10px;
            word-break: break-all;
            overflow-wrap: break-word;
          ">Portfolio</div>
        </div>
      </div>
    `;
    
    // Store full data for modal (include category for proper API calls)
    const cardDataWithCategory = { ...cardData, category };
    card.setAttribute('data-full-content', JSON.stringify(cardDataWithCategory));
    
    // Add event listeners to the dynamically created card
    card.addEventListener('mousemove', handleCardInteraction);
    card.addEventListener('mouseleave', handleCardReset);
    card.addEventListener('touchmove', (e) => {
      e.preventDefault();
      handleCardInteraction(e);
    });
    card.addEventListener('touchend', handleCardReset);
    card.addEventListener('click', () => {
      openModal(card);
    });
    
    return card;
  }
  
  async function initializeAllCategories() {
    const categories = ['project', 'blog', 'github'];
    console.log('Auto-loading all categories with unified sorting:', categories);
    
    try {
      // Fetch all categories simultaneously
      const allPromises = categories.map(async (category) => {
        const apiUrl = category === 'github' ? 
          '/api/github/projects' : 
          `/api/content/${category}`;
          
        console.log('Fetching unified data from:', apiUrl);
        const response = await fetch(apiUrl);
        const data = await response.json();
        
        let categoryItems = [];
        if (category === 'github') {
          categoryItems = data.data || [];
        } else {
          categoryItems = data.data || [];
        }
        
        // Add category metadata to each item
        return categoryItems.map(item => ({
          ...item,
          category: category,
          isFeature: category === 'github' ? item.feature === true : item.metadata?.feature === true,
          sortDate: category === 'github' ? new Date() : new Date(item.metadata?.date || '2024-01-01')
        }));
      });
      
      // Wait for all API calls to complete
      const categoryResults = await Promise.all(allPromises);
      
      // Flatten all cards into single array
      const allCards = categoryResults.flat();
      console.log('All cards before sorting:', allCards.length);
      
      // Sort globally: Featured first, then by date within each group
      allCards.sort((a, b) => {
        // Primary: Featured cards first
        if (a.isFeature !== b.isFeature) {
          return b.isFeature - a.isFeature; // true (1) before false (0)
        }
        
        // Secondary: Date within each group (newest first)
        return b.sortDate.getTime() - a.sortDate.getTime();
      });
      
      console.log('Cards after unified sorting:', allCards.map(c => ({
        title: c.metadata?.title || c.display_name || c.title,
        category: c.category,
        featured: c.isFeature,
        date: c.sortDate
      })));
      
      // Create single unified container
      await createUnifiedContainer(allCards);
      
    } catch (error) {
      console.error('Failed to load unified categories:', error);
    }
  }

  async function createUnifiedContainer(allCards) {
    const grid = document.getElementById('grid');
    if (!grid) {
      console.error('Grid element not found for unified container!');
      return;
    }
    
    // Create single unified container
    const unifiedContainer = document.createElement('div');
    unifiedContainer.className = 'cards-container unified-container';
    unifiedContainer.setAttribute('data-category', 'unified');
    unifiedContainer.style.cssText = `
      display: grid;
      grid-template-columns: repeat(auto-fit, 140px);
      gap: 20px;
      margin: 1px 20px;
      padding-top: 2px;
      opacity: 1;
      transform: translateY(0);
      transition: all 0.5s ease, max-height 0.5s ease;
      justify-content: center;
      justify-items: center;
      width: calc(100% - 40px);
      overflow: visible;
    `;
    
    // Insert after grid
    grid.parentNode?.insertBefore(unifiedContainer, grid.nextSibling);
    
    // Create all cards first without animation
    const cards = [];
    allCards.forEach((cardData, index) => {
      const card = createCard(cardData, cardData.category, index);
      card.style.transform = 'scale(0) rotateY(180deg)';
      card.style.opacity = '0';
      card.style.transition = 'none';
      unifiedContainer.appendChild(card);
      cards.push(card);
    });
    
    // Wait for layout to settle, then animate cards in with staggered timing
    requestAnimationFrame(() => {
      cards.forEach((card, index) => {
        setTimeout(() => {
          card.style.transition = 'all 0.8s cubic-bezier(0.23, 1, 0.32, 1)';
          card.style.transform = 'scale(1) rotateY(0deg)';
          card.style.opacity = '1';
        }, index * 150);
      });
    });
  }

  // Run immediately and also on DOM ready
  function init() {
    if (initialized) {
      console.log('CardInteractions already initialized, skipping');
      return;
    }
    
    initialized = true;
    initializeCards();
    initializeAllCategories();
    console.log('CardInteractions initialized');
  }
  
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
  
  // Also run on window load as backup
  window.addEventListener('load', init);
</script>

<style>
  @keyframes holographicShimmer {
    0% {
      background-position: 0% 50%;
    }
    50% {
      background-position: 100% 50%;
    }
    100% {
      background-position: 0% 50%;
    }
  }
  
  .cards-container {
    animation: slideIn 0.5s ease-out;
  }
  
  @keyframes slideIn {
    from {
      opacity: 0;
      transform: translateY(30px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  /* Card hover effects to match reference */
  .card:hover {
    transform: translateY(-30px) scale(1.15);
    box-shadow: 0 40px 80px rgba(0, 0, 0, 0.8), 0 20px 40px rgba(0, 0, 0, 0.5), 0 10px 20px rgba(0, 0, 0, 0.3);
  }

  /* Card flip animation for click */
  .card.flipping {
    animation: cardFlip 0.6s ease-in-out;
  }

  @keyframes cardFlip {
    0% {
      transform: translateY(-30px) scale(1.15) rotateY(0deg);
    }
    15% {
      transform: translateY(-50px) scale(1.25) rotateY(45deg);
    }
    30% {
      transform: translateY(-70px) scale(1.35) rotateY(135deg);
    }
    45% {
      transform: translateY(-85px) scale(1.4) rotateY(225deg);
    }
    60% {
      transform: translateY(-80px) scale(1.35) rotateY(315deg);
    }
    80% {
      transform: translateY(-50px) scale(1.25) rotateY(360deg);
    }
    100% {
      transform: translateY(0px) scale(1) rotateY(360deg);
    }
  }

  /* Enhanced emboss effect applied to ALL cards */
  .card .card-image::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: 
      linear-gradient(135deg, rgba(255, 255, 255, 0.6) 0%, transparent 30%),
      linear-gradient(315deg, rgba(0, 0, 0, 0.4) 0%, transparent 25%),
      radial-gradient(ellipse at 20% 20%, rgba(255, 255, 255, 0.7) 0%, transparent 40%),
      radial-gradient(ellipse at 80% 80%, rgba(0, 0, 0, 0.3) 0%, transparent 35%),
      radial-gradient(ellipse at 60% 40%, rgba(255, 255, 255, 0.5) 0%, transparent 30%),
      radial-gradient(ellipse at 30% 70%, rgba(0, 0, 0, 0.2) 0%, transparent 25%);
    mix-blend-mode: hard-light;
    opacity: 0;
    transition: opacity 0.3s ease;
    z-index: 2;
    pointer-events: none;
    border-radius: 8px;
  }

  .card:hover .card-image::after {
    opacity: 1;
  }

  /* Static directional light effect for ALL cards */
  .card .card-image::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: 
      linear-gradient(135deg, 
        rgba(255, 255, 255, 0.4) 0%, 
        rgba(255, 255, 255, 0.2) 25%, 
        transparent 50%),
      radial-gradient(ellipse at 25% 25%, 
        rgba(255, 255, 255, 0.5) 0%, 
        rgba(255, 255, 255, 0.2) 30%, 
        transparent 60%);
    mix-blend-mode: overlay;
    opacity: 0;
    transition: opacity 0.3s ease;
    z-index: 1;
    pointer-events: none;
    border-radius: 8px;
  }

  .card:hover .card-image::before {
    opacity: 1;
  }

  /* Enhanced dynamic directional light with mouse positioning for ALL cards */
  .card .card-front::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: 
      radial-gradient(ellipse at var(--light-x, 30%) var(--light-y, 30%), 
        rgba(255, 255, 255, 0.6) 0%, 
        rgba(255, 255, 255, 0.3) 25%, 
        rgba(255, 255, 255, 0.1) 50%, 
        transparent 70%);
    mix-blend-mode: soft-light;
    opacity: 0;
    transition: opacity 0.3s ease;
    z-index: 3;
    pointer-events: none;
    border-radius: 8px;
  }

  .card:hover .card-front::before {
    opacity: 0.8;
  }

  /* Throttled hue-rotate holographic effect */
  .card.holographic .card-image {
    filter: contrast(1.2) saturate(1.3) hue-rotate(0deg);
    will-change: filter;
    transition: filter 0.3s ease;
  }

  /* Rarity indicators */
  .card.holographic::after {
    content: "FEATURE";
    position: absolute;
    top: 8px;
    right: 8px;
    background: linear-gradient(45deg, #00FF7F, #FF4500);
    color: #fff;
    font-size: 8px;
    font-weight: bold;
    padding: 2px 6px;
    border-radius: 3px;
    z-index: 6;
    text-shadow: none;
  }

  .card.foil::after {
    content: "FOIL";
    position: absolute;
    top: 8px;
    right: 8px;
    background: linear-gradient(45deg, #C0C0C0, #FFFFFF);
    color: #000;
    font-size: 8px;
    font-weight: bold;
    padding: 2px 6px;
    border-radius: 3px;
    z-index: 11;
    text-shadow: none;
  }

  /* Modal scrollbar styling */
  .modal-body {
    /* Firefox fallback */
    scrollbar-width: auto;
    scrollbar-color: #ffffff #1a1a1a;
  }
  
  .modal-body::-webkit-scrollbar {
    width: 16px;
  }
  
  .modal-body::-webkit-scrollbar-track {
    background: #1a1a1a;
    border-radius: 0;
  }
  
  .modal-body::-webkit-scrollbar-thumb {
    background: #ffffff;
    border-radius: 6px;
    border: 2px solid #1a1a1a;
  }
  
  .modal-body::-webkit-scrollbar-thumb:hover {
    background: #e0e0e0;
  }
  
  .modal-body::-webkit-scrollbar-corner {
    background: #1a1a1a;
  }

  /* Apply scrollbar styling to any scrollable content in modals */
  .modal .markdown-content,
  .modal .github-readme {
    scrollbar-width: auto;
    scrollbar-color: #ffffff #1a1a1a;
  }
  
  .modal .markdown-content::-webkit-scrollbar,
  .modal .github-readme::-webkit-scrollbar {
    width: 16px;
  }
  
  .modal .markdown-content::-webkit-scrollbar-track,
  .modal .github-readme::-webkit-scrollbar-track {
    background: #1a1a1a;
  }
  
  .modal .markdown-content::-webkit-scrollbar-thumb,
  .modal .github-readme::-webkit-scrollbar-thumb {
    background: #ffffff;
    border-radius: 6px;
    border: 2px solid #1a1a1a;
  }
  
  .modal .markdown-content::-webkit-scrollbar-thumb:hover,
  .modal .github-readme::-webkit-scrollbar-thumb:hover {
    background: #e0e0e0;
  }
</style>